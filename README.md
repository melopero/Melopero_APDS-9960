# Melopero_APDS-9960

## Install

To install the module, open a terminal and run this command:
```pip3 install melopero-apds9960```  

## Introduction 

The sensor is made up of four different 'engines':

- Proximity Engine

- Gesture Engine

- Color/Als Engine

- Wait Engine

The sensor works like a state machine where each engine represents a state. There are also the SLEEP and IDLE state.  
The states are entered sequentially in the order depicted below:

![States](/images/states.png)


## How to use

Importing the module and device object creation:

```python
import melopero_apds9960 as mp

device = mp.APDS_9960()
# Alternatively you can specify which i2c bus and address to use
device = mp.APDS_9960(i2c_addr=MY_ADDRESS, i2c_bus=MY_BUS)

# Reset device : Disables all engines and enters the SLEEP state
device.reset()
```

Enabling/Disabling the engines:

```python
device.enable_proximity_engine(enable=True)
device.enable_als_engine(enable=True)
device.enable_gesture_engine(enable=True)
device.enable_wait_engine(enable=True)
```

### General Device Method

To toggle between the low consumption SLEEP state and the operating IDLE state:  

```python
device.power_up(True) # Enter IDLE state
device.power_up(False) # Enter SLEEP state
```

Other general methods:  

```python
device.set_sleep_after_interrupt(True)
# Enters SLEEP state after an interrupt occurred

device.set_led_drive(led_drive)
# Sets the LED drive strength. Must be one of mp.APDS_9960.LED_DRIVE_N_mA

device.set_led_boost(led_boost)
# The LED_BOOST allows the LDR pin to sink more current above the maximum settings. Must be
# one of mp.APDS_9960.LED_BOOST_N (where N is the percentage).

device.get_status()
# Returns a dictionary containing information about the device status.
```

### Proximity engine

To read the last measured proximity value (to update the proximity values the engine must be enabled):

```python
device.get_proximity_data()
# Returns a value ranging from 0 (far) to 255 (near)
```

#### Proximity interrupts

```python
device.enable_proximity_interrupts(enable=True)

device.clear_proximity_interrupts()

device.set_proximity_interrupt_thresholds(low, high) 
# The Proximity Interrupt Threshold sets the high and low trigger points for the comparison
# function which generates an interrupt. If the value generated by the proximity channel,
# crosses below the lower threshold or above the higher threshold, an interrupt may be
# signaled to the host processor.

device.set_proximity_interrupt_persistence(persistance)
# The Interrupt Persistence sets a value which is compared with the accumulated amount
# Proximity cycles in which results were outside threshold values. Any Proximity result
# that is inside threshold values resets the count.
```

#### Advanced settings

```python
device.set_proximity_gain(prox_gain)
# prox_gain must be one of mp.APDS_9960.PROXIMITY_GAIN_NX

device.set_proximity_pulse_count_and_length(pulse_count, pulse_length)
# The proximity pulse count is the number of pulses to be output on the LDR pin. The proximity
# pulse length is the amount of time the LDR pin is sinking current during a proximity pulse.
# pulse_count must be in range [1-64] and pulse_length must be one of mp.APDS_9960.
# PULSE_LEN_N_MICROS
```

### Gesture engine

There are multiple conditions and options to enter the gesture engine state. The engine has to be enabled before the gesture state can be entered.

1)  
    The sensor enters the gesture engine state immediately skipping the proximity engine state:

    ```python
    device.enter_immediately_gesture_engine() # Sets the enter condition for the Gesture engine state to: enter immediately

    device.exit_gesture_engine() # Resets the enter condition
    
    # This methods are NOT meant to be called every measurement... they are called just
    # once to set the gesture engine state enter and exit condition
    ```

2)
    The sensor enters the gesture engine state only if the proximity measurement is over a certain threshold. The proximity engine state is not skipped.

    ```python
    device.set_gesture_prox_enter_threshold(enter_thr) # Sets the enter threshold

    device.set_gesture_exit_threshold(exit_thr) # Sets the exit threshold
    device.set_gesture_exit_persistence(persistence) 
    # Sets number of consecutive measurements that have to be below the exit threshold
    # to exit the gesture state.  
    set_gesture_exit_mask(mask_up, mask_down, mask_left, mask_right)
    # Controls which of the gesture detector photodiodes (UDLR) will be included to
    # determine a “gesture end” and subsequent exit of the gesture state machine

    # This methods are NOT meant to be called every measurement... they are called just
    # once to set the gesture engine state enter and exit condition
    ```

The gesture data is made of datasets of four bytes that represent the values of the UDLR photodiodes.
The gesture data is stored in a FIFO queue and can be retrieved with the following methods:  

```python
n = device.get_number_of_datasets_in_fifo()

for i in range(n):
    dataset = device.get_gesture_data() # Reads the first dataset in the queue
    print(dataset)
```

Other general methods:

```python
device.is_gesture_engine_running()

device.get_gesture_status() 
# Returns a dictionary containing data about the gesture engine status
```

#### Gesture interrupts



#### Advanced settings

### Color/Als engine

#### Color/Als interrupts

#### Advanced settings